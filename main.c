#include "pso.h"
#include "calc_energy.h"
#include "convert.h"
#include "gradient_descent.h"

void write_xyz(const char* filename, const int* attyp, const double* coords, int natoms) {
  FILE* f = fopen(filename, "w");
  if (!f) {
    perror("fopen");
    return;
  }
  fprintf(f, "%d\n", natoms);
  fprintf(f, "Generated by PSO\n");

  for (int i = 0; i < natoms; ++i) {
    int z = attyp[i];
    double x = coords[3 * i + 0];
    double y = coords[3 * i + 1];
    double zc = coords[3 * i + 2];
    fprintf(f, "%d %.10f %.10f %.10f\n", z, x, y, zc);
  }
  fclose(f);
}

int main(int argc, char *argv[]) {
  if (argc == 1) {
    fprintf( stderr, "Too less arguments" );
    return 1;
  }
  const char* file_name = argv[1];
  ZMatrix* zm = read_zmatrix(file_name);
  if (!zm) {
    fprintf(stderr, "Could not open file.\n");
    return 1;
  }

  // Allocate and fill geo[3 x natoms]
  double* geo = calloc(3 * zm->natoms, sizeof(double));
  for (int i = 0; i < zm->natoms; i++) {
    geo[0 * zm->natoms + i] = zm->bond_len[i];
    geo[1 * zm->natoms + i] = zm->bond_ang[i];
    geo[2 * zm->natoms + i] = zm->dihed_ang[i];
  }

  double accuracy = 1.0;
  double electronic_temperature = 300.0;
  const int max_iter = 50;
  bool verbose = false;
  settings_loss_fct slf;
  init_settings_loss_fct(&slf, zm->natoms, zm->atomic_numbers,
                         zm->na, zm->nb, zm->nc,
                         electronic_temperature, accuracy, max_iter, verbose);

  void* data = &slf;
  double energy = calc_energy(geo, data);
  printf("GFN2-xTB single-point energy: %8.6f Eh\n", energy);

  int natoms = zm->natoms;
  int len = 3 * natoms;
  double* lb = (double*) calloc(len, sizeof(double));
  double* ub = (double*) calloc(len, sizeof(double));

  const double lower_lengths = 0.999;
  const double upper_lengths = 1.001;
  const double lower_angles = 0.99;
  const double upper_angles = 1.01;
  const double lower_dihedrals = 0.999;
  const double upper_dihedrals = 1.001;
  for (int i = 0; i < natoms; i++) {
    printf("%8.3f, %8.3f, %8.3f\n", geo[i], geo[natoms + i], geo[(natoms*2) + i]);
    // bond lengths
    lb[0 * natoms + i] = fmax(0.9, geo[i] * lower_lengths);
    ub[0 * natoms + i] = fmin(5.7, geo[i] * upper_lengths);

    // angles
    lb[1 * natoms + i] = fmax(0.523599, geo[natoms + i] * lower_angles);
    ub[1 * natoms + i] = fmin(3.05, geo[natoms + i] * upper_angles);

    // dihedrals
    lb[2 * natoms + i] = fmax(-M_PI, geo[(natoms*2) + i]*lower_dihedrals);
    ub[2 * natoms + i] = fmin(M_PI, geo[(natoms*2) + i]*upper_dihedrals);
  }

  Result res = {0};
  const int npop = 20;
  const int ngen = 20;
  pso(lb, ub, ngen, npop, len, -100, data, calc_energy, 1234, &res);

  const double lr = 0.1;
  const double beta = 0.9;
  const double tol = 1e-18;
  const int max_iter_optim = 1000;
  const int check = gradient_descent(calc_energy_and_grad,
                                     geo, len, lr, beta, tol, max_iter_optim, data, &res);

  bool fail = gmetry(slf.natoms, res.parameters, slf.na, slf.nb, slf.nc, slf.coord);
  if (fail) {
    fprintf(stderr, "Couldn't convert the optimized parameters to XYZ\n");
  } else {
    write_xyz("Result.xyz", slf.attyp, slf.coord, slf.natoms);
  }

  destroy_settings_loss_fct(&slf);
  free(geo);
  free_zmatrix(zm);
  free(lb);
  free(ub);
  free(res.parameters);
  return EXIT_SUCCESS;
}
